---
title: "NaN !== NaN: you wouldn't want it any other way"
created_at: 2013/07/06
published: true
---

`NaN !== NaN` for a good reason. It's funny it's considered a 'bad part' in lots of '[Javascript](http://net.tutsplus.com/tutorials/javascript-ajax/top-10-things-that-javascript-got-wrong/) [sucks](https://wiki.theory.org/YourLanguageSucks#Type_System) [lol](https://twitter.com/damln/status/198052578163036160)' posts as it's exactly the same in [Java](http://stackoverflow.com/questions/8819738/why-does-double-nan-double-nan-return-false), [Python](http://stackoverflow.com/a/944712/427710) and [.NET](http://msdn.microsoft.com/en-us/library/system.double.nan.aspx#remarksToggle).

`NaN` is the placeholder answer to questions that are not mathematically sensible . Just like there's no sensible answer to "what is the weight of the verb 'laugh'?", there are numerical questions we can't give a good answer to:

~~~javascript
Number(undefined) // NaN
0 / 0 // NaN
Math.log(-1) // NaN
Math.acos(2) // NaN
parseInt("I hate maths, can we just use words?") // NaN
~~~

Since `NaN` is given as the same "that's a dumb question" answer to all dumb questions, if it were equal to itself we'd get some strange behaviour. Would anyone prefer the following equality tests to pass?

~~~javascript
Math.log(-1) === parseInt("oh want a number? one")
0 / 0 === Math.acos(2)
~~~

Commonly, the next thing after bemoaning this 'problem' is to question how we can identify `NaN` values if we `NaN !== NaN`. Well: Javascript has contained the global `isNaN()` function from version one.

`isNaN()` can be tricky thanks to implicit coercion on being passed strings or literals. However, when using `isNaN()` that's usually fine as you're expecting a numeric. If you've somehow got code that could either be a string or a number (yuk) you can shim it with `function isNaN(x) { return x !== x }`, or wait for the [ES6 version](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN).

It's valid to argue that throwing an exception would be a neater and more helpful alternative: e.g Ruby throws the exception `Numerical argument is out of domain` for `log(-1)`. This makes it clear what's gone wrong, and will stop execution rather than letting `NaN` be passed around. However, `NaN` is specified by the [standard](https://en.wikipedia.org/wiki/IEEE_floating_point) [JS uses](http://www.ecma-international.org/ecma-262/5.1/#sec-4.3.23) for floating point arithmetic and therefore 'NaN' is consistently used instead of exceptions in numerical operations.

Javascript has flaws, but the 'WAT' meme has lead to some innocent 'good parts' being speciously condemned along with them.
