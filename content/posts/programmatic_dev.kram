---
title: Programmatic development environment
created_at: 2013/04/22
---

I've switched to a programmatically configured development environment. It takes some work to setup, but it's saved me a heap of time already, even for a bootstrapped one-man product.

By programatic development environement I mean all of the tools I use, and my development server and services, are installed and configured via code. If I wanted to I could get a fresh laptop, install git and the chef gem, and I'd have a new development environment in 10 minutes, which mirrors my production servers, and with all my favourite tools configured as I like them.

To summaries the pros and cons I've found:

- minimise production/development difference, an evergreen source of bugs
- make it easy to instantly bring on new developers or contractors
- makes it worth spending time configuring things right - you know you'll have to do it once, ever
- lowers productivity risk of OS/HDD meltdown or theft
- makes having a unified dev environment for pairing very simple

The sole con for me has been the up-front cost. If you like GUI editors or IDEs this technique would also be a lot trickier as they'll live on your host machine, but I'm sure you could supplment it to cover that too.

## Tools used

- Chef - defines and creates enviroment
- VirtualBox - runs a virtual machine to contain your environment
- Vagrant - script creation of virtual machines
- Tmux or screen (opt
o l
onal) - keep a persistant development environement

## Chef

Chef allows you to define your server configuration in code. It uses a Ruby-based DSL, so it's either familiar for you as a Rubyist, or a new language that's easy and useful to learn. When Chef runs it ensures a server is in a specified state; the first run will be installation, later runs for deployments or maintainence.

It's primarily composed of cookbooks of recipies - the cookbook is the unit of distribution, the recipies are scripts to install or configure components of your system. There are heaps of cookbooks available for databases, daemons like runit and packaging systems.

Within recipies the work is done by resources - these are actions to take, files or templates to create, or packages to install. They are idempotent - specifying a desired state, they do nothing once that state is achieved regardless how many times Chef is run. For example, the file resource will ensure a file exists with specific ownership and permissions. The first time Chef runs a receipe containing this resource it's created, later it's ignored if unchanged, or reset to the specified state if anything has changed. 

A complete Chef tutorial would take too long - there are [great docs](http://docs.opscode.com/).

My strategy has been to split out the development environement into a separate receipe (ideally you could have a separate cookbook) which is placed in the run list for my local environment. This takes care of:

- dotfiles
- vim (editor), vim plugins
- tmux
- ack &amp; other command line tools
- local instances of Postgres, redis etc

Once the development receipe has been run I have my development repos cloned, my keys in place, my editor ready and configured. I can be writing, commiting and deploying code immediately.

## VirtualBox

Since we want to be able to quickly create and destroy development environments, it's best not to manage your machine's actual OS with Chef. That implies virtualisation.

VirtualBox is a free virtual machine runner. We'll not actually be doing anything with it aside from [downloading the installer](https://www.virtualbox.org/wiki/Downloads) and running it.

## Vagrant

We script VirtualBox via Vagrant. It's responsible for downloading, installing and configuring virtual-machines: port-forwarding, shared folders, and the specific OS you'd like to install. It hands off responsibility for configuration of that OS to a provisioner - in this case Chef, but alternatively bash or Puppet. 

Getting Vagrant is [really easy](http://downloads.vagrantup.com/) - again just download and run the installer. You'll then create a [Vagrant file](http://docs.vagrantup.com/v2/vagrantfile/index.html) which contains the configuration of your box (or boxes if you have a multi-server production environment). You [choose](http://www.vagrantbox.es/) a base OS ('box' for Vagrant) and use the Vagrant command line tool to install. 

You Vagrant file will contain configuration for the box, and for your provisioner, setting up the OS and your app's environment respectively. Here's a snippet from mine - you can see I'm forwarding ports so I can access services running on the box on my host browser.

~~~ruby
config.vm.host_name = "vagrant.vagrantup.com"

config.vm.box_url = "https://github.com/downloads/leapcode/minimal-debian-vagrant/wheezy.box"

config.vm.forward_port 80, 8080 # chef managed rails
config.vm.forward_port 3000, 3030 # dev rails in home
config.vm.forward_port 5678, 5678 # resque-web
config.vm.forward_port 3333, 3334 # nanoc

config.vm.provision :chef_solo do |chef|
  chef.cookbooks_path = ["site-cookbooks"]
  chef.roles_path = "roles"
  chef.data_bags_path = "data_bags"

  chef.add_recipe "skjs::development"
  chef.add_recipe "skjs"

  chef.json = {
    env: "development",
    unicorn_workers: 1,
    app_domain: "localhost",
  }
end
~~~

## Tmux or screen

If you use a terminal based editor like Vim or Emacs is being able to create persistant development environments. I keep a tmux session alive for each repository, tailing logs, running test servers and my editor.

If you prefer a GUI editor like Textmate, Sublime or an IDE, you could either use a shared folder to access the files, or run the editor within the dev env if it's supported by Linux. The second option is ideal as it lets you capture the config programatically - however it's likely to be slow as you're within the VM.


