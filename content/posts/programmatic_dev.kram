---
title: Programmatic development environment
created_at: 2013/04/22
ffs: hello
published: fishy
---

I've recently switched to an entirely programmatically configured development environment. It takes some work to setup, but I've saved a lot of time in aggregate. If you're using a tool like Chef or Puppet anyway, you'll have a head start.

What do I mean by programatic development environement? I mean all of the tools I use are installed and configured via script, rather than manual installation, and live in a repo. If I wanted to I could get a fresh laptop, install git and the chef gem, and I'd have a new development environment in 10 minutes, which mirros my production servers, and with all my favourite tools configured as I like them.

Differences between development and production environments are an evergreen source of bugs. Managing it with Chef lets you develop and test on the same OS, with the same packages, as you have in production.

Below I've outlined the tools I've used with some pointers on how they work and where to look.

## Tools

- Chef - define enviroment
- VirtualBox - run a virtual machine to your env
- Vagrant - script creation of virtual machines
- Tmux or screen (opt
o l
onal) - keep a persistant development environement

## Chef

Chef allows you to define your server configuration in code. It uses a Ruby-based DSL, so it's either familar for you as a Rubyist, or a new language that's easy and useful to learn. When Chef runs it ensures a server is in a specified state; the first run will be installation, later runs for deployments or maintainence.

It's primarily composed of cookbooks of recipies - the cookbook is the unit of distribution, the recipies are scripts to install or configure components of your system. There are heaps of cookbooks available, or you could simply capture an existing bash workflow.

Within recipies the work is done by resources - these are actions to take, files or templates to create, or packages to install. They are idempotent - specifying a desired state, and they do nothing once that state is achieved regardless how many times Chef is run. For example, the file resource will ensure a file exists with specific ownership and permissions. The first time Chef runs a receipe containing this resource it's created, later it's ignored if unchanged, or reset to the specified state if anything has changed. 

A complete Chef tutorial would take too long - there are [great docs](http://docs.opscode.com/).

My strategy has been to split out the development environement into a separate receipe (ideally you could have a separate cookbook) which is placed in the run list for my local environment. This takes care of:

- dotfiles
- vim (editor), vim plugins
- tmux
- ack &amp; other command line tools
- local instances of Postgres, redis etc

Once the development receipe has been run I have my development repos cloned, my keys in place, my editor ready and configured. I can be writing, commiting and deploying code immediately.

## VirtualBox

Since we want to be able to quickly create and destroy development environments, it's best not to manage your machine's actual OS with Chef. That implies virtualisation.

VirtualBox is a free virtual machine runner. We'll not actually be doing anything with it aside from [downloading the installer](https://www.virtualbox.org/wiki/Downloads) and running it.

## Vagrant

We script VirtualBox via Vagrant. It's responsible for downloading, installing and configuring virtual-machines: port-forwarding, shared folders, and the specific OS you'd like to install. It hands off responsibility for configuration of that OS to a provisioner - in this case Chef, but alternatively bash or Puppet. 

Getting Vagrant is [really easy](http://downloads.vagrantup.com/) - again just download and run the installer. You'll then create a [Vagrant file](http://docs.vagrantup.com/v2/vagrantfile/index.html) which contains the configuration of your box (or boxes if you have a multi-server production environment). You [choose](http://www.vagrantbox.es/) a base OS ('box' for Vagrant) and use the Vagrant command line tool to install. 

You Vagrant file will contain configuration for the box, and for your provisioner, setting up the OS and your app's environment respectively. Here's a snippet from mine - you can see I'm forwarding ports so I can access services running on the box on my host browser.

~~~ruby
config.vm.host_name = "vagrant.vagrantup.com"

config.vm.box_url = "https://github.com/downloads/leapcode/minimal-debian-vagrant/wheezy.box"

config.vm.forward_port 80, 8080 # chef managed rails
config.vm.forward_port 3000, 3030 # dev rails in home
config.vm.forward_port 5678, 5678 # resque-web
config.vm.forward_port 3333, 3334 # nanoc

config.vm.provision :chef_solo do |chef|
  chef.cookbooks_path = ["site-cookbooks"]
  chef.roles_path = "roles"
  chef.data_bags_path = "data_bags"

  chef.add_recipe "skjs::development"
  chef.add_recipe "skjs"

  chef.json = {
    env: "development",
    unicorn_workers: 1,
    app_domain: "localhost",
  }
end
~~~

## Tmux or screen

Another advantage of this setup if you use a terminal based editor like Vim or Emacs is being able to create persistant development environments. I keep a tmux session alive for each repository, tailing logs, running test servers and my editor.

If you prefer a GUI editor like Textmate, Sublime or an IDE, you could either use a shared folder to access the files, or run the editor within the dev env if it's supported by Linux. The second option is ideal as it lets you capture the config programatically - however it's likely to be slow as you're within the VM.


